= Development =
Assuming you have successfully installed libifmap2c on your system you can start writing a MAP Client. 

There's not much documented here, sorry. Please look into the examples folder to get a glimpse of how you can use libifmap2c.

== Some Sample Code  ==
The following code realizes a MAP Client that sends two metadata updates
using one publishRequest.

{{{
/* filename example-mapc1.cpp */
#include <iostream>
#include <list>

#include <libifmap2c/ssrc.h>
#include <libifmap2c/requests.h>
#include <libifmap2c/identifiers.h>
#include <libifmap2c/metadata.h>


// libifmap2c namespace
using namespace ifmap2c;

using namespace std;

// Example client for the Wiki, very extensive documented.
int main(int argc, char *argv[])
{
	if (argc != 5) {
		cout << "Usage: " << argv[0] << " ifmap-server-url"
			" user pass capath" << endl;
		return 1;
	}

	// Create a synchronous send receive channel using basic
	// authentication
	// the parameters are as follows:
	// ifmap-server-url, user, password, capath (path where the server
	// certificate is lying prepared with c_rehas)
	SSRC *ssrc = SSRC::createSSRC(argv[1], argv[2], argv[3], argv[4]);

	// Note:
	// To use certificate based authentication one has to use
	// SSRC::createSSRC(url, /* server url */
	// 		    key, /* path to private key in PEM format */
	// 		    password, /* private key password */
	// 		    certificate, /* path to certificate */
	// 		    capath /* as for basic authentication */)

	// Create identifiers used for the request using the
	// Identifiers class
	IpAddress *ip1 = Identifiers::createIPv4("192.168.0.1");
	MacAddress *mac1 = Identifiers::createMac("aa:bb:cc:dd:ee:ff");
	IpAddress *ip2 = Identifiers::createIPv4("192.168.0.2");
	MacAddress *mac2 = Identifiers::createMac("aa:bb:cc:dd:ee:01");

	// create a metadata object, using the Metadata class
	XmlMarshalable *ipmac = Metadata::createIpMac();

	// need to define the standard meta namespace somewhere,
	// could also be done on both publishUpdate elements or
	// on the publish element
	ipmac->addXmlNamespaceDefinition(TCG_META_NSPAIR);

	// create two publishUpdate elements with session lifetime
	// and two identfiers (link), we need to clone ipmac the first
	// time, else there will be the same pointer in two distinct
	// PublishUpdate objects, this would result in a double free
	// of the pointer, which is bad...
	PublishUpdate *pubUpdate1 = Requests::createPublishUpdate(ipmac->clone(),
			ip1, session, mac1);
	
	PublishUpdate *pubUpdate2 = Requests::createPublishUpdate(ipmac,
			ip2, session, mac2);

	// store the publishUpdate elements in a list
	list<SubPublish *> publishList;
	publishList.push_back(pubUpdate1);
	publishList.push_back(pubUpdate2);

	// initialize the a publish request with the elements stored
	// in the list
	PublishRequest *publishReq = Requests::createPublishReq(publishList);

	// These objects are now children of the publishReq object.
	// We shouldn't touch them... Make sure we won't.
	ip1 = NULL, ip2 = NULL, mac1 = NULL, mac2 = NULL;
	ipmac = NULL; pubUpdate1 = NULL, pubUpdate2 = NULL;
	publishList.clear();

	try {
		// run a newSession request
		ssrc->newSession();

		// run the publish request
		ssrc->publish(publishReq);

		// run end session request
		ssrc->endSession();

	// CommunicationError occurs if something goes wrong with the
	// certificate or the other side is not reachable
	} catch (CommunicationError e) {
		cerr << "CommunicationError: " << e.getMessage() << endl;

	// ErrorResultError is thrown, if a errorResult is received from
	// the server. For example InvalidSessionID or InvalidMetadata.
	} catch (ErrorResultError e) {
		cerr << "ErrorResult  " << endl;
		cerr << " ErrorCode   " << e.getErrorCodeString() << endl;
		cerr << " ErrorString " << e.getErrorString() << endl;

	// other things can come up here, but we ignore that for now
	} catch (...) {
		cerr << "Unidentified Error." << endl;
		throw; // Throw it up to print the name
	}

	// delting the publish request
	// this will delte every child element which was added,
	// i.e both PublishUpdate objects will be deleted, which
	// in turn results in deletion of the Identifier and
	// Metadata objects. Therefore, no need to free these
	// explicitly.
	delete publishReq;

	// deleting the SSRC, this will close the TCP connection
	delete ssrc;

	return 0;
}
}}}

Build the client:

{{{g++ -o example-mapc1 example-mapc1.cpp -lifmap2c}}}

Run the client:

{{{./example-mapc1 https://127.0.0.1:8443 test test ~/libifmap2c/build/capath/}}}

== Processing {{{SearchResult}}} / {{{PollResult}}} objects ==

What follows is a rather long example which shows how SearchResults can be
processed using the `getResultItem()` and `getResultItemsByType()` methods
provided by `SearchResult`.
In principal, the `SearchResult` objects contained in a `PollResult` can be
processed in the same way.

{{{

/* filename example-mapc2.cpp */
#include <iostream>
#include <list>

#include <libifmap2c/ssrc.h>
#include <libifmap2c/requests.h>
#include <libifmap2c/identifiers.h>
#include <libifmap2c/metadata.h>


// libifmap2c namespace
using namespace ifmap2c;

using namespace std;

typedef pair<string, string> STRP;


// Example client for the Wiki, very extensive documented.
int main(int argc, char *argv[])
{
	if (argc != 5) {
		cout << "Usage: " << argv[0] << " ifmap-server-url"
			" user pass capath" << endl;
		return 1;
	}

	// Create a synchronous send receive channel using basic
	// authentication
	// the parameters are as follows:
	// ifmap-server-url, user, password, capath (path where the server
	// certificate is lying prepared with c_rehas)
	SSRC *ssrc = SSRC::createSSRC(argv[1], argv[2], argv[3], argv[4]);

	// create Identifier objects using the Identifiers class
	IpAddress *ip1 = Identifiers::createIPv4("192.168.0.1");
	MacAddress *mac1 = Identifiers::createMac("aa:bb:cc:dd:ee:ff");
	IpAddress *ip2 = Identifiers::createIPv4("192.168.0.2");
	MacAddress *mac2 = Identifiers::createMac("aa:bb:cc:dd:ee:01");
	AccessRequest *ar1 = Identifiers::createAr("ar01");
	AccessRequest *ar2 = Identifiers::createAr("ar02");
	Identity *id = Identifiers::createIdentity(username, "fool");

	// create a metadata objects, using the Metadata class
	XmlMarshalable *ipmac = Metadata::createIpMac();
	XmlMarshalable *armac = Metadata::createArMac();
	XmlMarshalable *authas = Metadata::createAuthAs();


	ipmac->addXmlNamespaceDefinition(TCG_META_NSPAIR);
	armac->addXmlNamespaceDefinition(TCG_META_NSPAIR);
	authas->addXmlNamespaceDefinition(TCG_META_NSPAIR);

	PublishUpdate *pubUpdate1 = Requests::createPublishUpdate(ipmac->clone(),
			ip1, session, mac1->clone());
	
	PublishUpdate *pubUpdate2 = Requests::createPublishUpdate(ipmac,
			ip2, session, mac2->clone());
	
	PublishUpdate *pubUpdate3 = Requests::createPublishUpdate(armac->clone(),
			mac1, session, ar1->clone());
	
	PublishUpdate *pubUpdate4 = Requests::createPublishUpdate(armac,
			mac2, session, ar2->clone());
	
	PublishUpdate *pubUpdate5 = Requests::createPublishUpdate(authas->clone(),
			id->clone(), session, ar1);
	
	PublishUpdate *pubUpdate6 = Requests::createPublishUpdate(authas,
			id->clone(), session, ar2);


	// create lists of PublishUpdate objects to be used
	// in PublishRequest objets
	list<SubPublish *> publishList1, publishList2, publishList3;
	publishList1.push_back(pubUpdate1);
	publishList1.push_back(pubUpdate2);
	publishList2.push_back(pubUpdate3);
	publishList2.push_back(pubUpdate4);
	publishList3.push_back(pubUpdate5);
	publishList3.push_back(pubUpdate6);

	// initialize the PublishRequests with the elements stored
	// in the lists
	PublishRequest *publishReq1 = Requests::createPublishReq(publishList1);
	PublishRequest *publishReq2 = Requests::createPublishReq(publishList2);
	PublishRequest *publishReq3 = Requests::createPublishReq(publishList3);


	// create a search request
	SearchRequest *sreq = SearchRequest::createSearchRequest(
			FILTER_MATCH_ALL,		// match-links-filter
			5,				// max-depth
			FILTER_MATCH_ALL,		// result-filter
			SEARCH_NO_MAX_RESULT_SIZE,	//max-size
			id);				// start identifier


	// run everything ;-)
	try {
		// run a newSession request
		cout << "newSession... ";
		ssrc->newSession();
		cout << "Ok!" << endl;;

		cout << "session-id=" << ssrc->getSessionId();
		cout << " ifmap-publisher-id=" << ssrc->getPublisherId() << endl;

		// run the publish request
		cout << "publish 1...  ";
		ssrc->publish(publishReq1);
		cout << "Ok!" << endl;
		
	
		cout << "search 1...   ";
		SearchResult *result1 = ssrc->search(sreq);

		// this result should only contain one result item
		if (result1->getResultItems().size() != 1)
			cout << "Got more result items than "
				"expected for first search result" << endl;

		// if we search for the identity, we should get the wanted
		// result item
		ResultItem *ri = result1->getResultItem(id);
		if (ri == NULL) {
			cout << "The identity was not in the "
				"search result?!" << endl;
		} else {
			// The identity identifier should not have any
			// metadata attached to it:
			if (ri->getMetadataList().size() != 0) {
				cout << "Identity has Metadata "
					"attached to it?!" << endl;
			}
		}
		cout << "Ok!" << endl;

		cout << "publish 2...  ";
		ssrc->publish(publishReq2);
		cout << "Ok!" << endl;
		cout << "publish 3...  ";
		ssrc->publish(publishReq3);
		cout << "Ok!" << endl;


		cout << "search 2...   ";
		SearchResult *result2 = ssrc->search(sreq);

		// some sanity checks
		if (result2->getResultItems().size() != 13) {
			cout << "Got a different number of result "
				" items than expected for the second "
				"search" << endl;
		}

		// get the ip-mac link result item for ip1 and mac1
		ri = result2->getResultItem(ip1, mac1);
		if (ri == NULL) {
			cout << "Link between ip1 and mac1 not in the "
				"search result?!" << endl;
		} else {
			if (ri->getMetadataList().size() != 1) {
				cout << "More metadata than expected?" << endl;
			}

			list<XmlMarshalable *>mdlist = XmlMarshalable::findMatchingElements(
					ri->getMetadataList(), // where to look for matching elements
					"ip-mac",	// element name
					TCG_META_HREF);	// associated namespace
			if (mdlist.size() != 1) {
				cout << "ip-mac metadata not found!" << endl;
			}
		}

		// get all ResultItems having the type of the parameters given
		list<ResultItem *> ipmaclinks = result2->getResultItemsByType(ip1, mac1);
		list<ResultItem *> ars = result2->getResultItemsByType(ar1);

		if (ipmaclinks.size() != 2) {
			cout << "Wrong number of ipmaclinks" << endl;

		}
		if (ars.size() != 2) {
			cout << "Wrong number of ARs" << endl;
		}

		cout << "Ok!" << endl;

		// delete result1 and result2
		// be aware, any ResultItem which was taken from
		// these results will be deleted too!
		delete result1;
		delete result2;


		// run end session request
		cout << "endSession... ";
		ssrc->endSession();
		cout << "Ok!" << endl;;

	// CommunicationError occurs if something goes wrong with the
	// certificate or the other side is not reachable
	} catch (CommunicationError e) {
		cerr << "CommunicationError: " << e.getMessage() << endl;

	// ErrorResultError is thrown, if a errorResult is received from
	// the server. For example InvalidSessionID or InvalidMetadata.
	} catch (ErrorResultError e) {
		cerr << "ErrorResult  " << endl;
		cerr << " ErrorCode   " << e.getErrorCodeString() << endl;
		cerr << " ErrorString " << e.getErrorString() << endl;

	// other things can come up here, but we ignore that for now
	} catch (...) {
		cerr << "Unidentified Error." << endl;
		throw; // Throw it up to print the name
	}

	delete publishReq1;
	delete publishReq2;
	delete publishReq3;
	delete sreq;

	// deleting the SSRC, this will close the TCP connection
	delete ssrc;

	return 0;
}
}}}